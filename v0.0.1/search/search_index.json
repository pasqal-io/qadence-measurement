{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence Measurement","text":"<p>Qadence Measurement is a Python package that provides shared libraries for qadence.</p>"},{"location":"#pre-requisites","title":"Pre-requisites","text":"<p>The library uses the following tools:</p> <ul> <li>hatch for managing virtual environment and dependencies</li> <li>pytest for building the unit tests suite</li> <li>black, isort and flake8 for code formatting and linting</li> <li>mypy for static type checking</li> <li>pre-commit for applying linting and formatting automatically before committing new code</li> </ul> <p>We recommend to use <code>pyenv</code> for managing python versions for managing python versions both globally and locally:</p> <pre><code># System-wide install of a python version.\npyenv install 3.10\n\n# Use 3.10 everywhere.\npyenv global 3.10\n\n# Or locally in the current directory.\npyenv local 3.10\n</code></pre>"},{"location":"#install-from-pypi","title":"Install from PyPi","text":"<p><code>qadence-measurement</code> is available on PyPi through <code>pip</code>.</p> <pre><code>pip install qadence-measurement\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>All Pasqal quantum libraries require Python &gt;=3.9. For development, the preferred method to install this package is to use <code>hatch</code>. You can install from source by cloning this repository and run:</p> <pre><code>python -m pip install hatch\npython -m hatch -v shell\n\n# execute any script using the library\npython my_script.py\n</code></pre> <p>Alternatively, you can also:</p> <ul> <li>install with <code>pip</code> in development mode by simply running <code>pip install -e .</code>. Notice that in this way   you will install all the dependencies, including extras.</li> <li>install it with <code>conda</code> by simply using <code>pip</code> inside the Conda environment.</li> </ul>"},{"location":"#develop","title":"Develop","text":"<p>When developing the package, the recommended way is to create a virtual environment with <code>hatch</code> as shown above:</p> <pre><code>python -m pip install hatch\npython -m hatch -v shell\n</code></pre> <p>When inside the shell with development dependencies, install first the pre-commit hook: <pre><code>pre-commit install\n</code></pre></p> <p>In this way, you will get automatic linting and formatting every time you commit new code. Do not forget to run the unit test suite by simply running the <code>pytest</code> command.</p> <p>If you do not want to get into the Hatch shell, you can alternatively do the following:</p> <pre><code>python -m pip install hatch\npython -m hatch -v shell\n\n# install the pre-commit\npython -m hatch run pre-commit install\n\n# commit some code\npython -m hatch run git commit -m \"My awesome commit\"\n\n# run the unit tests suite\npython -m hatch run pytest\n</code></pre>"},{"location":"#document","title":"Document","text":"<p>You can improve the documentation of the package by editing this file for the landing page or adding new markdown or Jupyter notebooks to the <code>docs/</code> folder in the root of the project. In order to modify the table of contents, edit the <code>mkdocs.yml</code> file in the root of the project.</p> <p>In order to build and serve the documentation locally, you can use <code>hatch</code> with the right environment:</p> <pre><code>python -m hatch -v run docs:build\npython -m hatch -v run docs:serve\n</code></pre> <p>If you don't want to use <code>hatch</code>, just check into your favorite virtual environment and execute the following commands:</p> <pre><code>python -m pip install -r docs/requirements.txt\nmkdocs build\nmkdocs serve\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"CODE OF CONDUCT","text":"<p>Code of Conduct</p>"},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in qadence-measurement. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence-measurement, feel free to create an issue on qadence-measurement GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to qadence-measurement. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence-measurement</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence-measurement.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence-measurement.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"measurement/","title":"Measurement protocols","text":"<p>Sample-based measurement protocols are fundamental tools for the prediction and estimation of a quantum state as the result of NISQ programs executions. Their resource efficient implementation is a current and active research field. Currently, quantum state tomography is implemented in qadence-measurement.</p>"},{"location":"measurement/#quantum-state-tomography","title":"Quantum state tomography","text":"<p>The fundamental task of quantum state tomography is to learn an approximate classical description of an output quantum state described by a density matrix \\(\\rho\\), from repeated measurements of copies on a chosen basis. To do so, \\(\\rho\\) is expanded in a basis of observables (the tomography step) and for a given observable \\(\\hat{\\mathcal{O}}\\), the expectation value is calculated with \\(\\langle \\hat{\\mathcal{O}} \\rangle=\\textrm{Tr}(\\hat{\\mathcal{O}}\\rho)\\). A number of measurement repetitions in a suitable basis is then required to estimate \\(\\langle \\hat{\\mathcal{O}} \\rangle\\).</p> <p>The main drawback is the scaling in measurements for the retrieval of the classical expression for a \\(n\\)-qubit quantum state as \\(2^n \\times 2^n\\), together with a large amount of classical post-processing.</p> <p>For an observable expressed as a Pauli string \\(\\hat{\\mathcal{P}}\\), the expectation value for a state \\(|\\psi \\rangle\\) can be derived as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\langle \\psi | \\hat{\\mathcal{P}} |\\psi \\rangle=\\langle \\psi | \\hat{\\mathcal{R}}^\\dagger \\hat{\\mathcal{D}} \\hat{\\mathcal{R}} |\\psi \\rangle \\] <p>The operator \\(\\hat{\\mathcal{R}}\\) diagonalizes \\(\\hat{\\mathcal{P}}\\) and rotates the state into an eigenstate in the computational basis. Therefore, \\(\\hat{\\mathcal{R}}|\\psi \\rangle=\\sum\\limits_{z}a_z|z\\rangle\\) and the expectation value can finally be expressed as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\sum_{z,z'}\\langle z |\\bar{a}_z\\hat{\\mathcal{D}}a_{z'}|z'\\rangle = \\sum_{z}|a_z|^2(-1)^{\\phi_z(\\hat{\\mathcal{P}})} \\]"},{"location":"measurement/#using-tomography","title":"Using tomography","text":"<p>In Qadence, running a tomographical experiment is made simple by defining a <code>Measurements</code> object that captures all options for execution:</p> <pre><code>from torch import tensor\nfrom qadence import hamiltonian_factory, BackendName, DiffMode, NoiseHandler\nfrom qadence import chain, kron, X, Z, QuantumCircuit, QuantumModel\nfrom qadence_measurement.protocol import Measurements\nfrom qadence_measurement.utils.types import MeasurementProtocol\n\nblocks = chain(\n    kron(X(0), X(1)),\n    kron(Z(0), Z(1)),\n)\n\n# Create a circuit and an observable.\ncircuit = QuantumCircuit(2, blocks)\nobservable = hamiltonian_factory(2, detuning=Z)\n\n# Create a model.\nmodel = QuantumModel(\n    circuit=circuit,\n    observable=observable,\n    backend=BackendName.PYQTORCH,\n    diff_mode=DiffMode.GPSR,\n)\n\n# Define a measurement protocol by passing the shot budget as an option.\ntomo_options = {\"n_shots\": 100000}\ntomo_measurement = Measurements(protocol=MeasurementProtocol.TOMOGRAPHY, options=tomo_options)\n\n# Get the exact expectation value.\nexact_values = model.expectation()\n\n# Run the tomography experiment.\nestimated_values_tomo = tomo_measurement(model=model)\n</code></pre> <pre><code>Exact expectation value = tensor([[-2.]])\nEstimated expectation value tomo = tensor([[-2.]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"measurement/#getting-measurements","title":"Getting measurements","text":"<p>If we are interested in accessing the measurements for computing different quantities of interest other than the expectation values, we can access the measurement data via <code>data</code> as follows:</p> <pre><code>measurements_tomo = tomo_measurement.data\n</code></pre> <pre><code>MeasurementData(samples=[[[OrderedCounter({'11': 100000})], [OrderedCounter({'11': 100000})]]], unitaries=tensor([]))\n</code></pre>"},{"location":"measurement/classical_shadow/","title":"Classical shadows","text":"<p>A much less resource demanding protocol based on classical shadows has been proposed<sup>1</sup>. It combines ideas from shadow tomography<sup>2</sup> and randomized measurement protocols <sup>3</sup> capable of learning a classical shadow of an unknown quantum state \\(\\rho\\). It relies on deliberately discarding the full classical characterization of the quantum state, and instead focuses on accurately predicting a restricted set of properties that provide efficient resources for the study of the system.</p> <p>A random measurement consists of applying random unitary rotations before a fixed measurement on each copy of a state. Appropriately averaging over these measurements produces an efficient estimator for the expectation value of an observable. This protocol therefore creates a robust classical representation of the quantum state or classical shadow. The captured measurement information is then reuseable for multiple purposes, i.e. any observable expected value and available for noise mitigation postprocessing.</p> <p>A classical shadow is therefore an unbiased estimator of a quantum state \\(\\rho\\). Such an estimator is obtained with the following procedure<sup>1</sup>: first, apply a random unitary gate \\(U\\) to rotate the state: \\(\\rho \\rightarrow U \\rho U^\\dagger\\) and then perform a basis measurement to obtain a \\(n\\)-bit measurement \\(|\\hat{b}\\rangle \\in \\{0, 1\\}^n\\). Both unitary gates \\(U\\) and the measurement outcomes \\(|\\hat{b}\\rangle\\) are stored on a classical computer for postprocessing \\(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U\\), a classical snapshot of the state \\(\\rho\\). The whole procedure can be seen as a quantum channel \\(\\mathcal{M}\\) that maps the initial unknown quantum state \\(\\rho\\) to the average result of the measurement protocol:</p> \\[ \\mathbb{E}[U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U] = \\mathcal{M}(\\rho) \\Rightarrow \\rho = \\mathbb{E}[\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)] \\] <p>It is worth noting that the single classical snapshot \\(\\hat{\\rho}=\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)\\) equals \\(\\rho\\) in expectation: \\(\\mathbb{E}[\\hat{\\rho}]=\\rho\\) despite \\(\\mathcal{M}^{-1}\\) not being a completely positive map. Repeating this procedure \\(N\\) times results in an array of \\(N\\) independent, classical snapshots of \\(\\rho\\) called the classical shadow:</p> \\[ S(\\rho, N) = \\{ \\hat{\\rho}_1=\\mathcal{M}^{-1}(U_1^\\dagger |\\hat{b}_1\\rangle\\langle \\hat{b}_1|U_1),\\cdots,\\hat{\\rho}_N=\\mathcal{M}^{-1}(U_N^\\dagger |\\hat{b}_N\\rangle\\langle \\hat{b}_N|U_N)\\} \\]"},{"location":"measurement/classical_shadow/#running-classical-shadows","title":"Running classical shadows","text":"<p>Along the same lines as the example before, estimating the expectation value using classical shadows in Qadence only requires to pass the right set of parameters to the <code>Measurements</code> object:</p> <pre><code># Classical shadows are defined up to some accuracy and confidence.\nfrom qadence_measurement.utils.data_acquisition import number_of_samples\n\nshadow_options = {\"accuracy\": 0.1, \"confidence\": 0.1}\nN, K = number_of_samples(observable, shadow_options[\"accuracy\"], shadow_options[\"confidence\"])\nshadow_measurement = Measurements(protocol=MeasurementProtocol.SHADOW, options=shadow_options)\n\n# Run the shadow experiment.\nestimated_values_shadow = shadow_measurement(model=model)\n</code></pre> <pre><code>Estimated expectation value shadow = tensor([[-2.]])\n</code></pre> <p>Note that the option <code>n_shots</code> is by default 1, which means for one unitary, we sample only once. If we specify a higher number of shots, more samples are realized per unitary accordingly, and a different formula is used involving the Hamming distance denoted \\(D\\) (see Eq. 2.42 of Ref<sup>3</sup>): \\(\\(\\hat{\\rho}^{(r)} = 2^N \\bigotimes_{i=1}^N \\sum_{b_i} (-2)^{-D[b_i, b_i^{(r)}]} (U^\\dagger |\\hat{b_i}\\rangle\\langle \\hat{b_i}|U)\\)\\)</p>"},{"location":"measurement/classical_shadow/#getting-shadows","title":"Getting shadows","text":"<p>If we are interested in accessing the measurement data from shadows, we can access the measurement data via the <code>manager</code> attribute as follows:</p> <pre><code>measurements_shadows = shadow_measurement.data\n</code></pre> <pre><code>Sampled unitary indices shape:  torch.Size([10200, 2])\nShape of batched measurements:  torch.Size([1, 10200, 2])\n</code></pre> <p>In the case of shadows, the measurement data is composed of two elements: - <code>unitaries</code> refers to the indices corresponding to the randomly sampled Pauli unitaries \\(U\\). It is returned as a tensor of shape (shadow_size, n_qubits). Its elements are integer values 0, 1, 2 corresponding respectively to X, Y, Z. - the second one, <code>samples</code>, refers to the bistrings (or probability vectors if <code>n_shots</code> is higher than 1) obtained by measurements of the circuit rotated depending on the sampled Pauli basis. It as returned as a tensor of batched measurements with shape (batch_size, shadow_size, n_qubits) or a tensor of shape (batch_size, shadow_size, \\(2^n_qubits\\)) depending on the value of <code>n_shots</code>.</p> <p>Such a measurement data can be used directly for computing different quantities of interest other than the expectation values. For instance, we can do state reconstruction and use it to calculate another expectation value as follows:</p> <pre><code># reconstruct state from snapshots\nstate = shadow_measurement.reconstruct_state()\n\n# calculate expectations\nfrom qadence_measurement.utils.utils_trace import expectation_trace\nexp_reconstructed_state = expectation_trace(state, observable)\n</code></pre> <pre><code>tensor([[-1.9988]])\n</code></pre>"},{"location":"measurement/classical_shadow/#references","title":"References","text":"<ol> <li> <p>Hsin-Yuan Huang, Richard Kueng and John Preskill, Predicting Many Properties of a Quantum System from Very Few Measurements (2020) \u21a9\u21a9</p> </li> <li> <p>S. Aaronson. Shadow tomography of quantum states. In Proceedings of the 50th Annual A ACM SIGACT Symposium on Theory of Computing, STOC 2018, pages 325\u2013338, New York, NY, USA, 2018. ACM\u00a0\u21a9</p> </li> <li> <p>Aniket Rath. Probing entanglement on quantum platforms using randomized measurements. Physics [physics]. Universit\u00e9 Grenoble Alpes [2020-..], 2023. English. ffNNT : 2023GRALY072ff. fftel-04523142\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"measurement/robust_shadow/","title":"Robust shadows","text":"<p>Robust shadows <sup>2</sup> were built upon the classical shadow scheme but have the particularity to be noise-resilient. It involves an experimental simple calibration procedure based on the preparation of a all-zero state with very high fidelity. We then perform noisy randomized measurements to learn about the averaged, as known as <code>twirled</code>, effect of the noise, obtaining calibration coefficients for shadows. One can e\ufb03ciently characterize and mitigate noises in the shadow estimation scheme, given only minimal assumptions on the experimental conditions. Such a procedure has been used in <sup>4</sup> to estimate the Quantum Fisher information out of a quantum system. Note that robust shadows are equivalent to classical shadows in non-noisy settings by setting the <code>calibration</code> coefficients to \\(\\frac{1}{3}\\) for each qubit, as shown below:</p> <pre><code>from qadence_measurement.calibration import zero_state_calibration\n# Calibration coefficients are by default 1/3\ncalibration = zero_state_calibration(N, n_qubits=2, n_shots=100, backend=model.backend, noise=None)\n\nrobust_shadow_options = {\"shadow_size\": N, \"shadow_medians\": K, \"calibration\": calibration}\nrobust_shadow_measurement = Measurements(protocol=MeasurementProtocol.ROBUST_SHADOW, options=robust_shadow_options)\nestimated_values_robust_shadow = robust_shadow_measurement(model=model)\n</code></pre> <pre><code>Estimated expectation value shadow = tensor([[-2.0000]])\n</code></pre>"},{"location":"measurement/robust_shadow/#robust-shadow-tomography","title":"Robust shadow tomography","text":"<p>In this tutorial, we will estimate a physical property out of a quantum system, namely the purity of the partial traces, in the presence of measurement noise. To do so, we will use the formalism of classical shadows<sup>1</sup>, and especially their robust version<sup>2</sup>. This tutorial is inspired from a notebook example of robust shadow tomography from the randomized measurements toolbox<sup>5</sup> in Julia<sup>3</sup>.</p>"},{"location":"measurement/robust_shadow/#setting-the-model","title":"Setting the model","text":"<p>First, we will set the noise model and a circuit from which we will estimate the purity.</p>"},{"location":"measurement/robust_shadow/#noise-model","title":"Noise model","text":"<p>We will use a depolarizing noise model with a different error probability per qubit.</p> <pre><code>import torch\nfrom qadence import NoiseHandler, NoiseProtocol\n\ntorch.manual_seed(0)\nn_qubits = 2\nerror_probs = torch.clamp(0.1 + 0.02 * torch.randn(n_qubits), min=0, max=1)\n\nnoise = NoiseHandler(protocol=NoiseProtocol.DIGITAL.DEPOLARIZING, options={\"error_probability\": error_probs[0], \"target\": 0})\n\nfor i, proba in enumerate(error_probs[1:]):\n    noise.digital_depolarizing(options={\"error_probability\": proba, \"target\": i+1})\n</code></pre> <pre><code>Error probabilities = tensor([0.1308, 0.0941])\n</code></pre>"},{"location":"measurement/robust_shadow/#noiseless-circuit-and-model","title":"Noiseless circuit and model","text":"<p>Let us set the circuit without noise and calculating the expected purities:</p> <pre><code>from qadence import *\n\ntheta1 = Parameter(\"theta1\", trainable=False)\ntheta2 = Parameter(\"theta2\", trainable=False)\ntheta3 = Parameter(\"theta3\", trainable=False)\ntheta4 = Parameter(\"theta4\", trainable=False)\n\nblocks = chain(\n    kron(RX(0, theta1), RY(1, theta2)),\n    kron(RX(0, theta3), RY(1, theta4,),),\n)\n\ncircuit = QuantumCircuit(2, blocks)\n\nvalues = {\n    \"theta1\": torch.tensor([0.5]),\n    \"theta2\": torch.tensor([1.5]),\n    \"theta3\": torch.tensor([2.0]),\n    \"theta4\": torch.tensor([2.5]),\n}\n# no observable needed here\nmodel = QuantumModel(\n    circuit=circuit,\n)\n</code></pre> <pre><code>\n</code></pre> <p>For calculating purities, we can use the utility functions <code>partial_trace</code> and <code>purity</code>:</p> <pre><code>from qadence_measurement.utils.utils_trace import partial_trace, purity\n\ndef partial_purities(density_mat):\n    purities = []\n    for i in range(n_qubits):\n        partial_trace_i = partial_trace(density_mat, [i]).squeeze()\n        purities.append(purity(partial_trace_i))\n\n    return torch.tensor(purities)\n\nexpected_purities = partial_purities(model.run(values))\n</code></pre> <pre><code>Expected purities = tensor([0.8209, 0.7136])\n</code></pre>"},{"location":"measurement/robust_shadow/#add-noise-to-circuit","title":"Add noise to circuit","text":"<p>The circuit is defined as follows where we set the previous noise model in the last operations as measurement noise.</p> <pre><code>noisy_blocks = chain(\n    kron(RX(0, theta1), RY(1, theta2)),\n    kron(RX(0, theta3, NoiseHandler(protocol=NoiseProtocol.DIGITAL.DEPOLARIZING, options={\"error_probability\": error_probs[0], \"target\": 0})),\n        RY(1, theta4, NoiseHandler(protocol=NoiseProtocol.DIGITAL.DEPOLARIZING, options={\"error_probability\": error_probs[1], \"target\": 1})),\n        ),\n)\n\nnoisy_circuit = QuantumCircuit(2, noisy_blocks)\nnoisy_model = QuantumModel(\n    circuit=noisy_circuit,\n)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"measurement/robust_shadow/#shadow-estimations","title":"Shadow estimations","text":""},{"location":"measurement/robust_shadow/#vanilla-classical-shadows","title":"Vanilla classical shadows","text":"<p>We will first run vanilla shadows to reconstruct the density matrix representation of the circuit, from which we can estimate the purities.</p> <pre><code>from qadence_measurement.protocol import Measurements\nfrom qadence_measurement.utils.types import MeasurementProtocol\n\nshadow_options = {\"shadow_size\": 10200, \"shadow_medians\": 6, \"n_shots\":1000}\nshadow_measurements = Measurements(protocol=MeasurementProtocol.SHADOW, options=shadow_options)\nshadow_measurements.measure(noisy_model, param_values=values)\nvanilla_purities = partial_purities(shadow_measurements.reconstruct_state())\n</code></pre> <pre><code>Purities with classical shadows = tensor([0.7216, 0.6570])\n</code></pre> <p>As we can see, the estimated purities diverge from the expected ones due to the presence of noise. Next, we will use robust shadows to mitigate the noise effect.</p>"},{"location":"measurement/robust_shadow/#calibration-for-robust-shadows","title":"Calibration for Robust shadows","text":"<p>We now use an efficient calibration method based on the experimental demonstration of classical shadows<sup>4</sup>. A first set of measurements are used to determine calibration coefficients. The latter are used within robust shadows to mitigate measurement errors. Indeed, we witness below the estimated purities being closer to the analytical ones.</p> <pre><code>from qadence_measurement.calibration import zero_state_calibration\n\ncalibration = zero_state_calibration(n_unitaries=2000, n_qubits=circuit.n_qubits, n_shots=10000, noise=noise)\nrobust_options = {\"shadow_size\": 10200, \"shadow_medians\": 6, \"n_shots\":1000, \"calibration\": calibration}\nrobust_shadow_measurements = Measurements(protocol=MeasurementProtocol.ROBUST_SHADOW, options=robust_options)\nrobust_shadow_measurements.measure(noisy_model, param_values=values)\nrobust_purities = partial_purities(robust_shadow_measurements.reconstruct_state())\n</code></pre> <pre><code>Expected purities = tensor([0.8209, 0.7136])\nPurities with robust shadows = tensor([0.7652, 0.6962])\nPurities with classical shadows = tensor([0.7216, 0.6570])\n</code></pre> <ol> <li> <p>Hsin-Yuan Huang, Richard Kueng and John Preskill, Predicting Many Properties of a Quantum System from Very Few Measurements (2020) \u21a9</p> </li> <li> <p>Senrui Chen, Wenjun Yu, Pei Zeng, and Steven T. Flammia, Robust Shadow Estimation (2021) \u21a9\u21a9</p> </li> <li> <p>RandomMeas.jl tutorial robust shadow tomography \u21a9</p> </li> <li> <p>Vittorio Vitale, Aniket Rath, Petar Jurcevic, Andreas Elben, Cyril Branciard, and Beno\u00eet Vermersch, Robust Estimation of the Quantum Fisher Information on a Quantum Processor (2024) \u21a9\u21a9</p> </li> <li> <p>Andreas Elben, Steven T. Flammia, Hsin-Yuan Huang, Richard Kueng, John Preskill, Beno\u00eet Vermersch, and Peter Zoller, The randomized measurement toolbox (2022) \u21a9</p> </li> </ol>"}]}